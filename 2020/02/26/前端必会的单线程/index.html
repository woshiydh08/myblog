<!DOCTYPE html><html lang="cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="前端必会的单线程"><meta name="keywords" content=""><meta name="author" content="totoro"><meta name="copyright" content="totoro"><title>前端必会的单线程 | Yoo_dh</title><link rel="shortcut icon" href="/myblog/melody-favicon.ico"><link rel="stylesheet" href="/myblog/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/myblog/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、进程与线程"><span class="toc-number">1.</span> <span class="toc-text">一、进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-浏览器是多进程的"><span class="toc-number">1.1.</span> <span class="toc-text">1. 浏览器是多进程的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-渲染进程（浏览器内核）"><span class="toc-number">1.2.</span> <span class="toc-text">2. 渲染进程（浏览器内核）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、单线程的-JavaScript"><span class="toc-number">2.</span> <span class="toc-text">二、单线程的 JavaScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、同步与异步"><span class="toc-number">3.</span> <span class="toc-text">三、同步与异步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-同步"><span class="toc-number">3.1.</span> <span class="toc-text">1. 同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-异步"><span class="toc-number">3.2.</span> <span class="toc-text">2. 异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、异步过程"><span class="toc-number">4.</span> <span class="toc-text">四、异步过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、消息队列与事件循环"><span class="toc-number">5.</span> <span class="toc-text">五、消息队列与事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-事件循环（eventloop）"><span class="toc-number">5.1.</span> <span class="toc-text">1. 事件循环（eventloop）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-消息队列"><span class="toc-number">5.2.</span> <span class="toc-text">2. 消息队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、异步与事件"><span class="toc-number">6.</span> <span class="toc-text">六、异步与事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、生产者与消费者"><span class="toc-number">7.</span> <span class="toc-text">七、生产者与消费者</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/myblog/img/avatar.jpg"></div><div class="author-info__name text-center">totoro</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/myblog/archives"><span class="pull-left">文章</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/myblog/">Yoo_dh</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/myblog">首页</a><a class="site-page" href="/myblog/archives">文章</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">前端必会的单线程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-26</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的喃，异步由何而来的喃，我们将在这里逐渐讨论实现。</p>
<h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1-浏览器是多进程的"><a href="#1-浏览器是多进程的" class="headerlink" title="1. 浏览器是多进程的"></a>1. 浏览器是多进程的</h4><p>它主要包括以下进程：</p>
<ul>
<li>Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li>
<li>GPU 进程：用于 3D 绘制等，最多一个。</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li>
<li>浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</li>
</ul>
<h4 id="2-渲染进程（浏览器内核）"><a href="#2-渲染进程（浏览器内核）" class="headerlink" title="2. 渲染进程（浏览器内核）"></a>2. 渲染进程（浏览器内核）</h4><p>浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：</p>
<ul>
<li>GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li>
<li>JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li>
<li>事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li>
<li>定时触发器线程：传说中的 <code>setInterval</code> 与 <code>setTimeout</code> 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 <code>setTimeout</code> 中低于 4ms 的时间间隔算为 4ms 。</li>
<li>异步 http 请求线程：在 <code>XMLHttpRequest</code> 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>
</ul>
<p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中<strong>等到 JavaScript 引擎空闲时</strong>立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<h3 id="二、单线程的-JavaScript"><a href="#二、单线程的-JavaScript" class="headerlink" title="二、单线程的 JavaScript"></a>二、单线程的 JavaScript</h3><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p>
<p><strong>问题：首先为什么要引入单线程喃？</strong></p>
<p>我们知道：</p>
<ul>
<li>浏览器需要渲染 DOM</li>
<li>JavaScript 可以修改 DOM 结构</li>
<li>JavaScript 执行时，浏览器 DOM 渲染停止</li>
</ul>
<p>如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。</p>
<p>你可能会说，<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">web worker</a> 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。</p>
<p><strong>原因：避免 DOM 渲染的冲突</strong></p>
<p>当然，我们可以为浏览器引入<strong>锁</strong> 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。</p>
<p>引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例1</span></span><br><span class="line"><span class="keyword">let</span> i, sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i ++) &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>

<p>在实例1中，<code>sum</code> 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 <code>console.log(sum)</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">alert(<span class="string">'hello'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在实例2中，浏览器先打印 <code>1</code> ，然后弹出弹框，点击确定后才执行 <code>console.log(2)</code> 。</p>
<p><strong>总结：</strong></p>
<ul>
<li>优点：实现比较简单，执行环境相对单纯</li>
<li>缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li>
</ul>
<p>为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步</p>
<h3 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h3><h4 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(args...)</span><br></pre></td></tr></table></figure>

<p>如果在函数 <code>func</code> 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">Math</span>.floor(a)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-异步"><a href="#2-异步" class="headerlink" title="2. 异步"></a>2. 异步</h4><p>如果在函数 <code>func</code> 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'foo.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>JavaScript 采用异步编程原因有两点，</p>
<ul>
<li>一是 JavaScript 是单线程；</li>
<li>二是为了提高 CPU 的利用率。</li>
</ul>
<h3 id="四、异步过程"><a href="#四、异步过程" class="headerlink" title="四、异步过程"></a>四、异步过程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'data.json'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在执行这段代码时，<code>fs.readFile</code> 函数返回时，并不会立刻打印 <code>data</code> ，只有 <code>data.json</code> 读取完成时才打印。也就是异步函数 <code>fs.readFile</code> 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。</p>
<blockquote>
<p>主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。</p>
</blockquote>
<p>工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现喃？答案就是就是消息队列与事件循环。</p>
<h3 id="五、消息队列与事件循环"><a href="#五、消息队列与事件循环" class="headerlink" title="五、消息队列与事件循环"></a>五、消息队列与事件循环</h3><blockquote>
<p>工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。</p>
</blockquote>
<ul>
<li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li>
<li>事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li>
</ul>
<h4 id="1-事件循环（eventloop）"><a href="#1-事件循环（eventloop）" class="headerlink" title="1. 事件循环（eventloop）"></a>1. 事件循环（eventloop）</h4><p>主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。</p>
<p>大致实现过程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = queue.get()</span><br><span class="line">    execute(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'xxxx'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// output：4321 或 4312</span></span><br></pre></td></tr></table></figure>

<p>其中，主线程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>异步队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 100ms后</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// ajax加载完成之后</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。</strong></p>
<h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h4><p>其中，消息就是注册异步任务时添加的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">'XXX'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 <code>XXX</code>，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息队列里的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>callback</code> 是 AJAX 网络请求成功响应时的回调函数。</p>
<p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 <code>message</code> 函数)，并执行它。到此为止，就完成了工作线程对主线程的 <code>通知</code> ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="649" height="361"></svg>)</p>
<p>异步过程中的回调函数，一定不在当前这一轮事件循环中执行。</p>
<h3 id="六、异步与事件"><a href="#六、异步与事件" class="headerlink" title="六、异步与事件"></a>六、异步与事件</h3><p>消息队列中的每条消息实际上都对应着一个事件。</p>
<p>其中一个重要的异步过程就是： <strong>DOM事件</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>)</span><br><span class="line">button.addEventLister(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从异步的角度看，<code>addEventLister</code> 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。</p>
<p>事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。</p>
<p>另外，所有的异步过程也都可以用事件来描述。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(func, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 可以看成：</span></span><br><span class="line">timer.addEventLister(<span class="string">'timeout'</span>, <span class="number">1000</span>, func)</span><br></pre></td></tr></table></figure>

<p>其中关于事件的详细描述，可以看这篇文章： <a href="http://blog.xieliqun.com/2016/08/12/event-delegate/" target="_blank" rel="noopener">事件绑定、事件监听、事件委托</a>，这里不再深入介绍。</p>
<h3 id="七、生产者与消费者"><a href="#七、生产者与消费者" class="headerlink" title="七、生产者与消费者"></a>七、生产者与消费者</h3><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p>
<p>从生产者与消费者的角度看，异步过程是这样的：</p>
<blockquote>
<p>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。</p>
</blockquote>
<p>那么异步的实现方式有哪些？</p>
<ul>
<li>ES6之前：callback、eventloop、Promise</li>
<li>ES6：Generator</li>
<li>ES7:Async/Await</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/26/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B/">http://yoursite.com/2020/02/26/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请附上原文出处链接及本声明！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/myblog/2020/02/26/webpack/"><i class="fa fa-chevron-left">  </i><span>webpack</span></a></div><div class="next-post pull-right"><a href="/myblog/2019/02/26/JS%E7%BB%A7%E6%89%BF/"><span>原型链继承</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By totoro</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/myblog/js/utils.js?version=1.7.0"></script><script src="/myblog/js/fancybox.js?version=1.7.0"></script><script src="/myblog/js/sidebar.js?version=1.7.0"></script><script src="/myblog/js/copy.js?version=1.7.0"></script><script src="/myblog/js/fireworks.js?version=1.7.0"></script><script src="/myblog/js/transition.js?version=1.7.0"></script><script src="/myblog/js/scroll.js?version=1.7.0"></script><script src="/myblog/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/myblog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/myblog/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":1},"log":false});</script></body></html>